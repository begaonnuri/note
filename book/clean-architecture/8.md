# 8장 OCP: 개방-폐쇄 원칙



> 소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고 변경에는닫혀 있어야 한다.

소프트웨어 아키텍처를 공부하는 가장 근본적인 이유이다.

대부분은 OCP가 클래스와 모듈을 설계할 때 도움되는 원칙이라고 알고있지만 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.



## 사고 실험

재무제표를 웹 페이지로 보여주는 시스템이 있다고 생각하자. 웹으로만 보던 보고서를 출력하는 요구사항이 추가되었을 때 기존 코드를 얼마나 수정해야 할까?

이상적인 변경량은 0이다. 다른 목적으로 변경되는 요소를 적절하게 분리하고(SRP), 의존성을 체계화함으로써(DIP) 변경량을 최소화할 수 있다.

SRP를 통해 책임을 분리했다면 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.

A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드신 A 컴포넌트가 B 컴포넌트에 의존해야한다.

비즈니스 규칙을 포함한 모듈은 OCP를 가장 잘 준수할 수 있는 곳에 위치해서 최고의 보호를 받아야한다. 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호해야 한다.



## 방향성 제어

의존성을 역전시키기 위해 인터페이스를 생성할 수 있다. 인터페이스를 통해 구현 클래스 내부에 대해 너무 많이 알지 못하도록 한다.

인터페이스가 없다면 추이 종속성(transitive dependency)를 가지게 된다. 추이 종속성을 가지게 되면 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다'는 소프트웨어 원칙을 위반하게 된다.



## 결론

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 너무 많은 영향을 받지 않도록 하는 데 있다. 목표를 달성하기 위해 시스템을 컴포넌트 단위로 분리하고 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.